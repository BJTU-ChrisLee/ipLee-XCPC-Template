# 常用定义

```c++
typedef long long int ll;
typedef double db;
const db EPS=1e-7; // 有时候也用eps
```



# 一般技巧

## 输入输出

### `iostream`的设置

* 浮点数精度设置

  ```c++
  cout<<fixed<<setprecision(15);
  ```

* 关闭流同步

  `ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);`



### 非负整数快读

```c++
template<typename I>I qread(){
    I x=0;char ch=getchar();
    while(ch<'0' || ch>'9'){ ch=getchar(); }
    while(ch>='0' && ch<='9'){ x=x*10+ch-'0';ch=getchar(); }
    return x;
}
```



### 带负整数快读

```c++
template<typename I>I qread(){
    I x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
```



### `__int128`使用

```c++
// 需测试是否可用
__int128 get128() {
    __int128 x = 0, sgn = 1;
    char c = getchar();
    for (; c < '0' || c > '9'; c = getchar()) if (c == '-') sgn = -1;
    for (; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - '0';
    return sgn * x;
}
void print128(__int128 x) {
    if (x < 0) {
        putchar('-');x = -x;
    }
    if (x >= 10) print128(x / 10);
    putchar(x % 10 + '0');
}
```



### 整行读入

```c++
scanf("%[^\n]", s)  // 需测试是否可用
getline(cin, s)
gets(buf,MAXN,stdin);
```



## 二分

### 整数二分

对$[1,n]$​区间整数二分，$work(x)$​是一个函数，$x$​较大的时候为`true`，较小时为`false`，输出最小的令$work(x)$为`true`的$x$，如果不存在输出`0`

```c++
int il=1,ir=n,imid,re=0;
while(il<=ir){
    imid=(il+ir)>>1;
    if(work(imid)){
        re=imid;ir=imid-1;
    }else{
        il=imid+1;
    }
}
```



### 实数二分

对$[l,r]$​​​区间实数二分，找$work(x)$​​​为`true`最小的点，小于答案的$work$​​​为`false`，大等于的为`true`

```c++
db mid;
while(r-l>EPS){
    mid=(l+r)/2;
    if(work(mid)){
        r=mid;
    }else{
        l=mid;
    }
}
// 之后使用l或者r都行。。。反正区间范围很小了
```



### `STL`写法

```c++
lower_bound(a+1,a+n+1,num); // 返回指向a[1...n]中第一个大于等于num的数字的指针
upper_bound(a+1,a+n+1,num); // 返回指向a[1...n]中第一个大于num的数字的指针
// 如果不存在返回a+n+1
// 可以通过upper_bound查找小于等于某个数的元素数量
```



## 三分

### 整数三分

在区间$[l,r]$​上找类二次函数$f(x)$​​的极小整点，注意整数三分取不到边界点，需要特判

```c++
double tri(){
    int l=1,r=1e9;
    while(r-l>5){
        int lmid=(1ll*l*2+r)/3;
        int rmid=(1ll*l+r*2)/3;
        double flmid=f(lmid),frmid=f(rmid);
        if(flmid<=frmid){
            r=rmid;
        }else{
            l=lmid;
        }
    }
    double ans=f(l);
    for(int i=l+1;i<=r;++i){
        ans=min(f(i),ans);
    }
    return ans
}
```



### 实数三分

实数三分更简单些，也不需要考虑端点问题

这里求的是$f(x)$的极大值点

```c++
db l=0,r=1e9,lmid,rmid; // 根据需要取
while(r-l>eps){
    lmid=(l*2+r)/3;
    rmid=(l+r*2)/3;
    if(f(lmid)>f(rmid)){
        r=rmid;
    }else{
        l=lmid;
    }
}
// 之后用l或r都行
```



## 离散化

```c++
const int MAXN=1e5+10;
int v[MAXN],vd[MAXN],n,tot;
void lsh(){
    for(int i=1;i<=n;++i){
        vd[i]=v[i];
    }
    sort(vd+1,vd+n+1);
    tot=unique(vd+1,vd+n+1)-vd-1;
    for(int i=1;i<=n;++i){
        v[i]=lower_bound(vd+1,vd+tot+1,v[i])-vd;
    }
}
```

适用于下标从1开始的数组



## 莫队算法

### 基础莫队

```c++
typedef long long int ll;
const int N = 50005;
int n,m,maxn,c[N];
struct query {
	int il, ir, id;
	bool operator<(const query &x) const {
		if (il/maxn!=x.il/maxn) return il < x.il;
		return (il/maxn)&1?ir<x.ir:ir>x.ir;
	}
}qs[N];
void work(int co,ll p){...} // 自己设计
// in main
maxn = sqrt(n);
// 输入
sort(qs+1,qs+m+1);
cnt[c[1]]=1; // 初始区间放在了[1,1]，这样不容易错，但是记得要把相关信息也初始化了
for (int i=1,l=1,r=1;i<=m;i++) {
    while (l > qs[i].il) work(c[--l],1);
    while (r < qs[i].ir) work(c[++r],1);
    while (l < qs[i].il) work(c[l++],-1);
    while (r > qs[i].ir) work(c[r--],-1);
}
```



### 带修莫队（待填坑）



# 数学

## `gcd`

```c++
typedef long long int ll;
ll gcd(ll a, ll b){
	return b==0?a:gcd(b,a%b);
}
```

可以使用$\mathrm{lcm}(a,b)=\frac{ab}{\gcd(a,b)}$求$\mathrm{lcm}$

对于要取模的情况，可以使用分解因数做



## 快速运算

### 带模快速幂

带模版本

```c++
ll qpow(ll a,ll x,ll M){
    ll ret=1;
    while(x){
        if(x&1) ret=ret*a%M;
        a=a*a%M;x>>=1; // 这里有可能爆long long
    }
    return ret;
}
```

不带模版本根据带模版本更改就行



### 快速乘

不要使用$O(\log x)$​的“龟速乘”，除非发现可能被卡精度了，那玩意贼慢

```c++
long long qmul(unsigned long long x,unsigned long long y,ll m){
    unsigned long long tmp=(x*y-(unsigned long long)((long double)x/m*y)*m);
    return (tmp+m)%m;
}
```

（如果非要用龟速乘，直接搬快速幂的板子就行）



## 整除分块

用于求$\sum\limits_{r=1}\limits^{n}f(r)\lfloor \frac{k}{r}\rfloor$​​

这里`sumf(ll l,ll r)`是用来求$\sum\limits_{i=l}\limits^{r}f(i)$的

```c++
typedef long long int ll;
ll sumf(ll l,ll r){
    return (r-l+1)*(l+r)/2;
}
ll zcfk(ll n,ll k){
    ll ans=0;
    for(ll l=1,r;l<=n;l=r+1){
        if(k/l!=0) r=min(k/(k/l),n);
        else r=n;
        ans+=(k/l)*sumf(l,r);
    }
    return ans;
}
```



## 高维前缀和

对所有的$0\le i\le 2^n-1$，快速求解$\sum\limits_{j\subset i}a_j$

```c++
// f为读入的数据
for(int j = 0; j < n; ++j){
    for(int i = 0; i < 1 << n; ++i){
        if((i >> j) & 1) f[i] += f[i ^ (1 << j)];
    }
}
```

也可以求解$\sum\limits_{i\subset j}a_j$

```c++
for(int j = 0; j < n; ++j){
    for(int i = (1 << n)-1; i >= 0; --i){
        if(((i >> j) & 1)==0) f[i] += f[i ^ (1 << j)];
    }
}
```

时间复杂度$O(n2^n)$​，注意这两个前缀和都包括了自己



## 高斯消元

```c++
// n 方程个数，m 变量个数，a 是 n*(m+1) 的增广矩阵，free 是否为自由变量
// 返回自由变量个数，-1无解
const double EPS = 1e-8;
const int N = 2000 + 7;
double x[N];
bool free_x[N];
int sgn(double x) { return x < -EPS ? -1 : x > EPS; }
int gauss(vector<vector<double> >& a, int n, int m) {
    fill(x, x + m + 1, 0);
    fill(free_x, free_x + m + 1, true);

    // 求上三角矩阵
    int r = 0, c = 0;
    while (r < n && c < m) {
        int mr = r;
        for (int i = r + 1; i < n; i++) {
            if (abs(a[i][c]) > abs(a[mr][c])) mr = i;
        }
        if (mr != r) swap(a[r], a[mr]);
        if (!sgn(a[r][c])) {
            a[r][c] = 0;
            ++c;
            continue;
        }
        for (int i = r + 1; i < n; i++) {
            if (a[i][c]) {
                double t = a[i][c] / a[r][c];
                for (int j = c; j <= m; j++) a[i][j] -= a[r][j] * t;
            }
        }
        ++r, ++c;
    }
    for (int i = r; i < n; i++) {
        if (sgn(a[i][m])) return -1;
    }

    // 求解 x0, x1, ..., xm-1
    if (r < m) {
        for (int i = r - 1; i >= 0; i--) {
            int fcnt = 0, k = -1;
            for (int j = 0; j < m; j++) {
                if (sgn(a[i][j]) && free_x[j]) {
                    ++fcnt;
                    k = j;
                }
            }
            if (fcnt > 0) continue;
            double s = a[i][m];
            for (int j = 0; j < m; j++) {
                if (j != k) s -= a[i][j] * x[j];
            }
            x[k] = s / a[i][k];
            free_x[k] = 0;
        }
        return m - r;
    }
    for (int i = m - 1; i >= 0; i--) {
        double s = a[i][m];
        for (int j = i + 1; j < m; j++) s -= a[i][j] * x[j];
        x[i] = s / a[i][i];
    }
    return 0;
}
```



## 素数

### 艾筛

```c++
const int MAXN=1e8+10;
int mnf[MAXN];bool isprime[MAXN];
void init(){
	memset(isprime,true,sizeof(isprime));
	for(int i=1;i<MAXN;++i) mnf[i]=i;
	isprime[0]=isprime[1]=false;
	for(int i=2;i<MAXN;++i){
		if(isprime[i]){
			for(int j=i+i;j<MAXN;++j){
				if(isprime[j]) isprime[j]=false,mnf[j]=i;
			}
		}
	}
}
```

时间复杂度$O(n\log\log n)$



### $O(\log n)$判断素数

```c++
// O(logn)
// 前置：快速乘、快速幂
// int范围只需检查2, 7, 61
bool isprime(ll n) {
    if (n < 3) return n == 2;
    if (!(n & 1)) return false;
    ll d = n - 1, r = 0;
    while (!(d & 1)) d >>= 1, r++;
    static vector<ll> A = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    for (ll a : A) {
        ll t = qpow(a, d, n);
        if (t <= 1 || t == n - 1) continue;
        for (int i = 0; i < r; i++) {
            t = qmul(t, t, n);
            if (t == 1) return false;
            if (t == n - 1) break;
        }
        if (t != 1 && t != n - 1) return false;
    }
    return true;
}
```



## 递推逆元

```c++
ll inv[N];
void initInv() {
    inv[1]=1;
    for (int i=2;i<N;i++) {
        inv[i]=1LL*(MOD-MOD/i)*inv[MOD%i]%MOD;
    }
}
```



## 离散对数

```c++
// a ^ x = b (mod p)，要求模数为素数
ll BSGS(ll a, ll b, ll p) {
    a %= p;
    if (!a && !b) return 1;
    if (!a) return -1;
    map<ll, ll> mp;
    ll m = ceil(sqrt(p)), v = 1;
    for (int i = 1; i <= m; i++) {
        (v *= a) %= p;
        mp[v * b % p] = i;
    }
    ll vv = v;
    for (int i = 1; i <= m; i++) {
        auto it = mp.find(vv);
        if (it != mp.end()) return i * m - it->second;
        (vv *= v) %= p;
    }
    return -1;
}

// 模数可以非素数
ll exBSGS(ll a, ll b, ll p) {
    a %= p; b %= p;
    if (a == 0) return b > 1 ? -1 : (b == 0 && p != 1);
    ll c = 0, q = 1;
    for (;;) {
        ll g = gcd(a, p);
        if (g == 1) break;
        if (b == 1) return c;
        if (b % g) return -1;
        ++c; b /= g; p /= g; q = a / g * q % p;
    }
    map<ll, ll> mp;
    ll m = ceil(sqrt(p)), v = 1;
    for (int i = 1; i <= m; i++) {
        (v *= a) %= p;
        mp[v * b % p] = i;
    }
    for (int i = 1; i <= m; i++) {
        (q *= v) %= p;
        auto it = mp.find(q);
        if (it != mp.end()) return i * m - it->second + c;
    }
    return -1;
}

// 已知 x, b, p，求 a
ll SGSB(ll x, ll b, ll p) {
    ll g = primitive_root(p);
    return qk(g, BSGS(qk(g, x, p), b, p), p);
}
```



# 数据结构

## 并查集

### 一般并查集

```c++
const int MAXN=1e5+10;
struct USet{
    int fa[MAXN],sz[MAXN],sz;
    void init(){
        sz=_sz;
        for(int i=1;i<=sz;++i){
            fa[i]=i;sz[i]=1;
        }
    }
    int findfa(int x){ return fa[x]==x?x:fa[x]=findfa(fa[x]);}
    bool unio(int x,int y){ // 返回是否合并成功
        int xx=findfa(x),yy=findfa(y);
        if(xx==yy){
            return false;
        }else if(sz[xx]<sz[yy]){
            swap(xx,yy);
        }
        fa[yy]=xx;sz[xx]+=sz[yy];
        return true;
    }
    int size(int x){
        return sz[findfa(x)];
    }
}uset; // 不要开在栈里。。。有数组
```



### 动态开点并查集

```c++
// pa 为负数表示集合大小
unordered_map<int, int> pa;

void _set(int x) { if (!pa.count(x)) pa[x] = -1; }
int find(int x) { return (pa[x] < 0) ? x : pa[x] = find(pa[x]); }

void merge(int a, int b) {
    int x = find(a), y = find(b);
    if (x == y) return;
    if (pa[x] > pa[y]) swap(x, y);
    pa[x] += pa[y];
    pa[y] = x;
}
```



## ST表

```c++
const int MAXN=1e5+10,MAXLOG=20;
struct ST{
    static int lg2[MAXN],pow2[MAXN];
    int n;int V[MAXN],st[MAXN][MAXLOG];
    static void gen(){
        lg2[1]=0;
        for(int i=2;i<MAXN;++i){
            lg2[i]=lg2[i>>1]+1;
        }
        pow2[0]=1;
        for(int i=1;i<32;++i){
            pow2[i]=pow2[i-1]<<1;
        }
    }
    void init(){
        for(int i=1;i<=n;++i){
            st[i][0]=V[i];
        }
        for(int j=1;j<MAXLOG;++j){
            for(int i=1;i+pow2[j]-1<=n;++i){
                st[i][j]=max(st[i][j-1],st[i+pow2[j-1]][j-1]);
            }
        }
    }
    int query(int il,int ir){
        int s=lg2[ir-il+1];
        return max(st[il][s],st[ir-pow2[s]+1][s]);
    }
}; // 不要开在栈里，另外如果只有一个ST表就不用写结构体了
// 在main里先ST.gen()，然后再对每个ST表.init()
```



## 树状数组

### 单点操作区间和查询树状数组

```c++
const int MAXN=5e4+10;
struct TreeArray{
	int ta[MAXN],n;
	static int lowbit(int x){
		return x&(-x);
	}
	void build(){
		for(int i=1,j;i<=n;++i){
			j=i+lowbit(i);
			if(j<=n){
				ta[j]+=ta[i];
			}
		}
	}
	void add(int x,int p){
		while(x<=n){
			ta[x]+=p;x+=lowbit(x);
		}
	}
	int _sum(int x){
		int re=0;
		while(x){
			re+=ta[x];x-=lowbit(x);
		}
		return re;
	}
	int sum(int l,int r){
		return _sum(r)-_sum(l-1);
	}
};
```



### 带区间操作树状数组

```c++
typedef long long int ll;
const int MAXN=5e5+10;
struct TreeArray{
	ll b[MAXN],bi[MAXN];int n;
	void init(int _n,ll * a){ // 使用差分数组O(n)建树，注意需要memset
		n=_n;
		for(int i=1,j;i<=n;++i){
			b[i]+=a[i];bi[i]+=a[i]*i;
			j=i+lowbit(i);
			if(j<=n){
				b[j]+=b[i];bi[j]+=bi[i];
			}
		}
	}
	static int lowbit(int x){
		return (x)&(-x);
	}
	void _add(int i,ll p){
		int x=i;ll pp=p*i;
		while(x<=n){
			b[x]+=p;bi[x]+=pp;x+=lowbit(x);
		}
	}
	void add(int l,int r,ll p){
		_add(l,p);_add(r+1,-p);
	}
	ll _sum(ll * t,int r){
		ll re=0;
		while(r){
			re+=t[r];r-=lowbit(r);
		}
		return re;
	}
	ll sum(int l,int r){
		return ((r+1)*_sum(b,r)-l*_sum(b,l-1)) - (_sum(bi,r)-_sum(bi,l-1));
	}
};
```

一定记得建树时使用差分数组！



### 二维区间操作树状数组

```c++
typedef long long int ll;
const int N=1e5+10;
struct TreeArray {
    ll t[N][N];
    static int lowbit(int x) { return x & (-x); }
    void add(int x, int y, int d) {
        for (int i = x; i <= n; i += lowbit(i))
            for (int j = y; j <= m; j += lowbit(j)) t[i][j] += d;
    }
    ll get(int x, int y) {
        ll sum = 0;
        for (int i = x; i > 0; i -= lowbit(i))
            for (int j = y; j > 0; j -= lowbit(j)) sum += t[i][j];
        return sum;
    }
    ll query(int x, int y, int xx, int yy) {
        return get(xx, yy) - get(x - 1, yy) - get(xx, y - 1) + get(x - 1, y - 1);
    }
};
TreeArray t0, t1, t2, t3;
void add4(int x, int y, ll d) {
    t0.add(x, y, d);
    t1.add(x, y, d * x);
    t2.add(x, y, d * y);
    t3.add(x, y, d * x * y);
}
void range_add(int x, int y, int xx, int yy, ll d) {
    add4(x, y, d);
    add4(x, yy + 1, -d);
    add4(xx + 1, y, -d);
    add4(xx + 1, yy + 1, d);
}
ll get4(int x, int y) {
    return (x + 1) * (y + 1) * t0.get(x, y)
    - (y + 1) * t1.get(x, y)
    - (x + 1) * t2.get(x, y)
    + t3.get(x, y);
}
ll range_sum(int x, int y, int xx, int yy) {
    return get4(xx, yy) - get4(x - 1, yy) - get4(xx, y - 1) + get4(x - 1, y - 1);
}
```



## 动态开点线段树

经典加法乘法两种操作的线段树。做题的时候可以和板子对，不要照抄板子

```c++
typedef long long int ll;
const ll M=571373;
const int MAXN=1e5+10;
struct TNode{
	ll tagM,tagA,S;int ls,rs;
}node[MAXN<<2];
#define ls(x) (node[x].ls)
#define rs(x) (node[x].rs)
#define tagM(x) (node[x].tagM)
#define tagA(x) (node[x].tagA)
#define sum(x) (node[x].S)
int tot;
int newNode(){int x=++tot;memset(node+x,0,sizeof(TNode));node[x].tagM=1;return x;}
ll V[MAXN];
int build(int x,int l,int r){
	// debug(x);debug(l);debug(r);cout_n;
	if(l==r){
		sum(x)=V[l]%M;
		return x;
	}
	int mid=(l+r)>>1;
	ls(x)=build(newNode(),l,mid);rs(x)=build(newNode(),mid+1,r);
	sum(x)=(sum(ls(x))+sum(rs(x)))%M;
	return x;
}
void pd(int x,int l,int r){
	int mid=(l+r)>>1;
	if(!ls(x)){ls(x)=newNode();}
	if(!rs(x)){rs(x)=newNode();}
	int lx=ls(x),rx=rs(x);
	sum(lx)=(tagM(x)*sum(lx)%M+(tagA(x)*(mid-l+1))%M)%M;
	tagA(lx)=tagA(lx)*tagM(x)%M;
	tagA(lx)=(tagA(lx)+tagA(x))%M;
	tagM(lx)=tagM(lx)*tagM(x)%M;

	sum(rx)=(tagM(x)*sum(rx)%M+(tagA(x)*(r-mid)%M))%M;
	tagA(rx)=tagA(rx)*tagM(x)%M;
	tagA(rx)=(tagA(rx)+tagA(x))%M;
	tagM(rx)=tagM(rx)*tagM(x)%M;

	tagM(x)=1;tagA(x)=0;
}
void add(int id,int l,int r,int ql,int qr,ll a){
	if(l>=ql && r<=qr){
		tagA(id)=(tagA(id)+a)%M;
		sum(id)=(sum(id)+(r-l+1)*a)%M;
		return;
	}
	pd(id,l,r);
	int mid=(l+r)>>1;
	if(mid>=ql){add(ls(id),l,mid,ql,qr,a);}
	if(mid+1<=qr){add(rs(id),mid+1,r,ql,qr,a);}
	sum(id)=(sum(ls(id))+sum(rs(id)))%M;
}
void mul(int id,int l,int r,int ql,int qr,ll m){
	if(l>=ql && r<=qr){
		tagA(id)=tagA(id)*m%M;
		tagM(id)=tagM(id)*m%M;
		sum(id)=sum(id)*m%M;
		return;
	}
	pd(id,l,r);
	int mid=(l+r)>>1;
	if(mid>=ql){mul(ls(id),l,mid,ql,qr,m);}
	if(mid+1<=qr){mul(rs(id),mid+1,r,ql,qr,m);}
	sum(id)=(sum(ls(id))+sum(rs(id)))%M;
}

ll query(int id,int l,int r,int ql,int qr){
	if(l>=ql && r<=qr){
		return sum(id);
	}
	pd(id,l,r);
	ll res=0;
	int mid=(l+r)>>1;
	if(mid>=ql){res+=query(ls(id),l,mid,ql,qr);}
	if(mid+1<=qr){res+=query(rs(id),mid+1,r,ql,qr);}
	return res%M;
}
```

遇到问题时查下：

1. 有没有建树
2. 有没有`push_down`、`push_up`



## 主席树

```c++
const int MAXN=1e5+10;
struct PNode{
	int ls,rs,val;
}node[MAXN<<5];
#define ls(p) (node[p].ls)
#define rs(p) (node[p].rs)
#define val(p) (node[p].val)
int rt[MAXN],tot;
int newNode(int cpy=0){
	int u=++tot;
	memcpy(node+u,node+cpy,sizeof(PNode));
	return u;
}
int build(int l,int r){
	int u=newNode();
	if(l==r){
		return u;
	}
	int mid=(l+r)>>1;
	ls(u)=build(l,mid);rs(u)=build(mid+1,r);
	return u;
}
int add(int l,int r,int v,int rtp){
	int u=newNode(rtp);++val(u);
	if(l==r){
		return u;
	}
	int mid=(l+r)>>1;
	if(v<=mid){
		ls(u)=add(l,mid,v,ls(rtp));
	}else{
		rs(u)=add(mid+1,r,v,rs(rtp));
	}
	return u;
}
int query(int rtl,int rtr,int l,int r,int k){
	if(l==r){
		return l;
	}
	int mid=(l+r)>>1;
	if(val(ls(rtr))-val(ls(rtl))>=k){
		return query(ls(rtl),ls(rtr),l,mid,k);
	}else{
		return query(rs(rtl),rs(rtr),mid+1,r, k-(val(ls(rtr))-val(ls(rtl))) );
	}
}
```



## 线段树合并

这里使用的例题：权值线段树，记录出现次数最多的数及其次数。做题的时候可以和板子对，不要照抄板子

```c++
const int MAXN=1e5+10,MAXLOG=25,N=100000;
struct Node{
	int ls,rs,typ,mxc;
}node[MAXN*80];
#define ls(x) (node[x].ls)
#define rs(x) (node[x].rs)
#define typ(x) (node[x].typ)
#define mxc(x) (node[x].mxc)

int rt[MAXN],tot;

typedef pair<int,int>pii;
#define id first
#define ct second

void upd(pii & p,pii np){
	if(p.ct<np.ct){
		p=np;
	}else if(p.ct==np.ct && p.id>np.id){
		p=np;
	}
}

pii query(int p,int l,int r,int ql,int qr){
	if(ql<=l && r<=qr){
		return pii(typ(p),mxc(p));
	}
	int mid=(l+r)>>1;pii res=pii(0,0);
	if(mid>=ql && ls(p)) upd(res,query(ls(p),l,mid,ql,qr));
	if(mid<qr && rs(p)) upd(res,query(rs(p),mid+1,r,ql,qr));
	return res;
}

int newNode(int z=0){int p=++tot;mxc(p)=ls(p)=rs(p)=0;typ(p)=z;return p;}

int add(int p,int l,int r,int z,int d){
	if(!p) p=newNode(z);
	if(l==r) {mxc(p)+=d;return p;}
	int mid=(l+r)>>1;
	if(z<=mid) ls(p)=add(ls(p),l,mid,z,d);
	if(z>mid) rs(p)=add(rs(p),mid+1,r,z,d);
	if( mxc(rs(p))>mxc(ls(p)) ){
		mxc(p)=mxc(rs(p));typ(p)=typ(rs(p));
	}else{
		mxc(p)=mxc(ls(p));typ(p)=typ(ls(p));
	}
	return p;
}

int merge(int r1,int r2,int l,int r){
	if(!r1) return r2;
	if(!r2) return r1;
	if(l==r){
		mxc(r1)+=mxc(r2);typ(r1)=l;return r1;
	}
	int mid=(l+r)>>1;
	ls(r1)=merge(ls(r1),ls(r2),l,mid);
	rs(r1)=merge(rs(r1),rs(r2),mid+1,r);
	if( mxc( ls(r1) ) < mxc( rs(r1) ) ){
		mxc(r1)=mxc(rs(r1));typ(r1)=typ( rs(r1) );
	}else{
		mxc(r1)=mxc(ls(r1));typ(r1)=typ( ls(r1) );
	}
	return r1;
}
```





## 倍增LCA

```c++
const int MAXN=5e5+10,MAXLOG=25;
int lg2[MAXN],fa[MAXN][MAXLOG],dep[MAXN],n,m;
vector<int>G[MAXN];
void init(){
    lg2[1]=0;
    for(int i=2;i<MAXN;++i)
        lg2[i]=lg2[i>>1]+1;
}

void dfs(int u,int fu){
	dep[u]=dep[fu]+1;fa[u][0]=fu;
	for(int i=1;i<MAXLOG;++i)
		fa[u][i]=fa[ fa[u][i-1] ][i-1];
	for(int v:G[u])
		if(v!=fu)
			dfs(v,u);
}

int lca(int x,int y){
	if(dep[x]<dep[y])
		swap(x,y);
	while(dep[x]>dep[y])
		x=fa[x][ lg2[dep[x]-dep[y]] ];
	if(x==y)
		return x;
	for(int k=lg2[dep[x]];k>=0;--k)
		if(fa[x][k]!=fa[y][k])
			x=fa[x][k],y=fa[y][k];
	return fa[x][0];
}
```

`lg2[x]`表示$\lfloor\log _2 x\rfloor$，也可以表示`x`二进制表达的位数数量减一（或从0开始计数的最高位位数）；`fa[x][k]`表示`x`的向上跳$2^k$​​次所在结点；`lca`的最后过程相当于模拟二进制过程



# 字符串

## 双哈希

只提供写法参考，实际上不一定要这么写

如果时限很紧的话，试着把`ll`换成`int`

```c++
typedef long long int ll;
const int MAXN=1e5+10;
const ll M[2]={1000000009,998244353};
const ll B[2]={29,31};

ll powB[2][MAXN];
void init(){
	powB[0][0]=1;powB[1][0]=1;
	for(int i=1;i<MAXN;++i){
		powB[0][i]=powB[0][i-1]*B[0]%M[0];powB[1][i]=powB[1][i-1]*B[1]%M[1];
	}
}
struct THash{
	ll h[2];
	void move(char ch){
		h[0]=(h[0]*B[0]+ch)%M[0];
		h[1]=(h[1]*B[1]+ch)%M[1];
	}
	bool operator < (const THash & th) const {
		if(h[0]!=th.h[0]){
			return h[0]<th.h[0];
		}else{
			return h[1]<th.h[1];
		}
	}
	void prt(){
		cout<<h[0]<<" , "<<h[1];
	}
};
THash minu(const THash & thl,int l,const THash & thr,int r){
    // 给l,r处hash的前缀和，得到[l+1,r]的hash
	THash th;
	th.h[0]=( thr.h[0]- (thl.h[0]*powB[0][r-l]%M[0]) + M[0] ) %M[0];
	th.h[1]=( thr.h[1]- (thl.h[1]*powB[1][r-l]%M[1]) + M[1] ) %M[1];
	return th;
}
```



## Manacher

字符串下标从$0$开始，长度为$n$​

半径长度`d1`、`d2`均为从位置`i`到回文串最右端位置包含的字符个数（包括`i`）

```c++
vector<int> d1(n);
for (int i = 0, l = 0, r = -1; i < n; i++) {
    int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);
    while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {
        k++;
    }
    d1[i] = k--;
    if (i + k > r) {
        l = i - k;
        r = i + k;
    }
}
vector<int> d2(n);
for (int i = 0, l = 0, r = -1; i < n; i++) {
    int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
    while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {
        k++;
    }
    d2[i] = k--;
    if (i + k > r) {
        l = i - k - 1;
        r = i + k;
    }
}
```



## 前缀函数

字符串下标从`0`开始。前缀函数定义：$\pi[i]$表示$s[0...i]$中最长相同真前缀和真后缀的长度

```c++
vector<int> getPi(string & s) {
    int n = (int)s.length();vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) j = pi[j - 1];
        if (s[i] == s[j]) j++;
        pi[i] = j;
    }
    return pi;
}
```



## AC自动机

```c++
const int N=60,L=1e6+10; // 模式串、文本串长度
const int MAXN = N * 10000; // 这里空间能开大点就开大点
struct ACAuto{
	int tot,tr[MAXN][26],fail[MAXN],cnt[MAXN];
    // cnt[u]:u字符串出现次数
	void init() {
		for(int i=0;i<=tot;++i){
			memset(tr[i],0,sizeof(tr[i]));
			fail[i]=cnt[i]=0;
		}
		tot=0;
	}
	void insert(char * s, int id) {  // id 表示原始字符串的编号
		int u = 0,c;char * p=s;
		while(*p){
			c=*(p++)-'a';
			if(!tr[u][c]) tr[u][c]=++tot;
			u=tr[u][c];
		}
		++cnt[u];
	}
	void build() {
		queue<int>q;
  		for (int i=0;i<26;i++){
    		if (tr[0][i]) q.push(tr[0][i]);
  		}
		while (q.size()) {
    		int u = q.front();q.pop();
    		for (int i=0;i<26;i++) {
				if (tr[u][i]){
        			fail[tr[u][i]]=tr[fail[u]][i];q.push(tr[u][i]);
				}else{
        			tr[u][i]=tr[fail[u]][i];
				}
    		}
  		}
	}

	int query(char * t){
		int u=0,c,res=0;
		while(*t){
			c=*(t++)-'a';
			u=tr[u][c];
			for(int j=u;j && cnt[j]!=-1;j=fail[j]){
				res+=cnt[j];cnt[j]=-1;
			}
		}
		return res;
	}
};
```

注意：

1. $v=fail[u]$表示$v$是$u$的最长后缀
2. 这个使用的是[oi-wiki的自动机改进](https://oi-wiki.org/string/ac-automaton/#_6)，`tr[u][c]`可能直接表示转移，即`tr[fail[u]][i]`，所以直接使用`tr[u][c]`转移就行
3. 在`query`的时候，有时候需要在`fail`树上跳，一定要注意将`vis`过的点标记上，不要重复跳，不然时间复杂度就爆炸



## 后缀数组（待填坑）



## SAM

```c++
int c2i(char ch){
	return ch-'a';
}
struct SNode{
	int len,link,nxt[26];
};
const int MAXLEN=1e5+10;
struct SAM{
	SNode node[MAXLEN<<1];
	int sz,lst;
	void init(){
        for(int i=0;i<sz;++i) memset(node+i,0,sizeof(SNode));
		node[0].len=0;node[0].link=-1;sz=1;lst=0;
	}
	void extend(char ch){
		int cur=sz++,c=c2i(ch);
		node[cur].len=node[lst].len+1; // 新结点p长度一定是lst加一
		int p=lst;
		while(p!=-1 && !node[p].nxt[c]){
			node[p].nxt[c]=cur;p=node[p].link;
			// p的link指p最长非相同endpos后缀的结点
			// 所有的这些结点如果nxt[c]没有的话都应该指向p
		}
		if(p==-1){ // 已经跳到不存在的点了
			node[cur].link=0;
		}else{ // 跳到的点存在
			int q=node[p].nxt[c]; // p通过c转移的结点
			if(node[p].len+1==node[q].len){
				node[cur].link=q;
				// 如果q对应的最长串就是p最长的加上c
				// 那么直接将cur的link给到q就行
			}else{ // 如果不是，就需要克隆点
				int cln=sz++;
				// cln表示的是新的endpos
				// 这个endpos满足：其最长串是p最长串加上c
				node[cln].len=node[p].len+1;
				memcpy(node[cln].nxt,node[q].nxt,sizeof(node[q].nxt));
				node[cln].link=node[q].link;
				while(p!=-1 && node[p].nxt[c]==q){
					node[p].nxt[c]=cln;
					p=node[p].link;
				}
				node[q].link=node[cur].link=cln;
			}
		}
		lst=cur;
	}
};
```

注意：

1. 在构建图的过程中，`link`和`nxt`都是可能改变的，所以不要妄图使用DAG的信息在线计算答案
2. $minlen(v)=len(link(v))+1$​​，并且每次增加的子串数量为$len(cur)-minlen(cur)+1=len(cur)-len(link(cur))$​
3. 在SAM中有一条“主链”，也就是整串的链，这条链的结点表示真实存在于原字符串的$endpos$​（或者说右端点），可能有特殊含义
4. `cur`表示的就是右端点所在的`endpos`！利用这点可以求类似“`endpos`中有多少个不同位置的子串”问题
5. 构建完之后，`lst`通过`link`到达的所有状态都是“终止状态”，并且点的值域是`[0,sz-1]`！也就是`sz`并不对应一个点
6. **多样例记得清空`node`信息！**



# 图论

## 最小生成树

注意：判断是否是连通图，下面的板子没有验证连通性

### `prim`

$O(n^2)$​​​的，使用邻接矩阵存图。如果一道题用不了`kruskal`，那就说明是稠密图，那用$O(n^2)$​的`prim`就行

```c++
typedef long long int ll;
const int MAXN=5e3+10;
ll co[MAXN][MAXN],le[MAXN]; // 邻接矩阵 最小值数组
int n;bool vis[MAXN];

ll prim(){
	memset(le,0x3f,sizeof(le));memset(vis,false,sizeof(vis));
	ll res=0,len=0;int u=1;
	while(u){
		vis[u]=true;res+=len;
        for(int v=1;v<=n;++v){
            if(!vis[v]){
                le[v]=min(le[v],co[u][v]);
            }
        }
		u=0; // le[0]就是INF
		for(int i=1;i<=n;++i){
			if(!vis[i] && le[i]<le[u]){
				u=i;len=le[i];
			}
		}
	}
	return res;
}
```



### `kruskal`

最常用写法

本质就是`sort`+并查集，就不贴代码了



## 最短路

### `dijkstra`

```c++
const int MAXN=1e5+10;
typedef long long int ll;
const ll INF=0x3f3f3f3f3f3f3f3f;
struct edge{
    int v;ll w;
    edge(int _v=0,ll _w=0):v(_v),w(_w){
    }
};
struct cmpNode{
    bool operator () (const edge & e1,const edge & e2) const {
        return e1.w>e2.w;
    }  
};
vector<edge>G[MAXN];
ll dist[MAXN];int n,m;bool vis[MAXN];
void dijkstra(int s){
    memset(dist,0x3f,sizeof(dist));
    memset(vis,false,sizeof(vis));
    priority_queue<edge,vector<edge>,cmpNode>q;
    dist[s]=0;q.push(edge(s,dist[s]));
    while(q.size()){
        edge e=q.top();q.pop();
        if(vis[e.v]){
            continue;
        }
        vis[e.v]=true;
        for(auto v:G[e.v]){
            if(!vis[v.v] && dist[v.v]>dist[e.v]+v.w){
                dist[v.v]=dist[e.v]+v.w;q.push(edge(v.v,dist[v.v]));
            }
        }
    }
}
```



### `SPFA`

```c++
typedef long long int ll;
struct node {
    int v;
    ll w;
    node(int v=0, ll w=0) : v(v), w(w){};
};
const int MAXN = 1e5+100;
const ll INF = 0x3f3f3f3f3f3f3f3f;
ll dist[MAXN];int dcnt[MAXN];bool inQ[MAXN];
vector<node> G[MAXN];
bool relax(int u,int v,ll w) {
    if (dist[v]>dist[u]+w) {
        dist[v]=dist[u]+w;++dcnt[v];
        return true;
    }else{
        return false;
    }
}
bool SPFA(int s,int cntV) { // 返回是否有负环，s是源，cntV是点的数量
    memset(dist, (int)INF, sizeof(dist));memset(dcnt, 0, sizeof(dcnt));
    queue<int>Q;inQ[s]=true;dist[s] = 0;Q.push(s);
    while (!Q.empty()) {
        int u = Q.front();Q.pop();
        inQ[u]=false;
        for (node i : G[u]) {
            if ( relax(u, i.v, i.w) && !inQ[i.v] ) {
                if (dcnt[i.v]>=cntV+1) {
                    return true;
                }
                Q.push(v);
                inQ[v]=true;
            }
        }
    }
    return false;
}
```



### `floyd`

```c++
typedef long long int ll;
const ll INF=0x3f3f3f3f3f3f3f3f;
const int MAXN=3e2+10;
int n;
ll dist[MAXN][MAXN];
void floyd(){
    // 先将dist里面图的边权标上，其他的是INF
    for (int k=1; k<=n; k++) {
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=n; j++) {
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
            }
        }
    }
}
```



## `A*`

`A*`可以看作一种图论搜索，下面的“点”都可以理解成一种状态

定义起点$s$​​、终点$t$​​，从起点开始的距离函数$g(x)$​，到终点的距离函数$h(x)$​，以及估价函数$f(x)=g(x)+h(x)$​

`A*`算法每次从优先队列中取出一个$f$​最小的元素，然后更新其相邻的状态（就是加入队列）

定义$h^*(x)$​为$x$​到终点$t$​实际的距离函数，实际上$h^*(x)$就是反向图$s$到$x$的最短路

如果$h\le h^*$​​​，则`A*`可以找到最优解；在满足前式的情况下，如果$h$​​满足三角形不等式，那么`A*`过程中不会多次从某优先队列中取某一个点（此时时间复杂度最有保障）

三角形不等式指：如果有边$\lang u,v\rang$​那么$h(v)\le h(u)+w(\lang u,v\rang )$​



## 差分约束

<img src="src/截屏2021-08-17 22.04.01.png" style="zoom:50%;" />





## 拓扑排序

注意在需要字典序最小的情况可以使用优先队列维护待遍历队列，其他的不写了



## 欧拉回路/路径

### 有向图欧拉回路/路径

```c++
const int MAXN=1e5+10;
vector<int>G[MAXN];
int en[MAXN],n,m,din[MAXN],dout[MAXN];
void add(int u,int v){
	G[u].push_back(v);++din[v];++dout[u];
}
stack<int>res;
void dfs(int u){
	int ie=en[u]++;
	while(ie<G[u].size()){
		dfs(G[u][ie]);
		ie=en[u]++;
	}
	res.push(u);
}
// in main
int s=1; // 起点，注意需要先判断有没有欧拉回路/路径存在，以及起点应该在哪
dfs(s);
while(res.size()){
    cout<<res.top()<<' ';res.pop();
}
```



### 无向图欧拉回路/路径

```c++
const int MAXN=1e3+10;
int G[MAXN][MAXN];
int ct[MAXN],n,m,d[MAXN];
void add(int u,int v){
	++G[u][v];++G[v][u];++d[u];++d[v];
}
stack<int>res;
void dfs(int u){
	for(int v=ct[u];v<=n;++v){
		while(G[u][v]){
			--G[u][v];--G[v][u];
			ct[u]=v;
			dfs(v);
		}
	}
	res.push(u);
}
// in main
dfs(s); // 找到起点s
while(res.size()){
    cout<<res.top()<<' ';res.pop();
}
```



## 强连通分量

```c++
// Tarjan算法，注意这里dfn[0]和scid[0]都表示计数器
int dfn[MAXN],low[MAXN],scid[MAXN];
struct SC{
	int sz,pt;
}sc[MAXN];
stack<int>scst;
bool inst[MAXN];
void scdfs(int u){
	dfn[u]=low[u]=++dfn[0];
	scst.push(u);inst[u]=true;
	for(auto v:G[u]){
		if(!dfn[v]){
			scdfs(v);low[u]=min(low[u],low[v]);
		}else if(inst[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		int id=++scid[0],v;
		while(scst.top()!=u){
			v=scst.top();scst.pop();inst[v]=false;
			++sc[id].sz;scid[v]=id;
		}
		scst.pop();inst[u]=false;
		++sc[id].sz;scid[u]=id;
	}
}
```



## SAT问题

### Horn-SAT

数据格式

1. 命题`x`为真：`x`
2. 命题`x`为假：`!x`
3. 命题`a`、`b`等可以推出`x`为真：`a b -> x`
4. 命题`a`、`b`等可以推出`x`为假：`a b -> !x`

其中`a`、`b`、`x`均为数字

```c++
const int MAXN=1e6+10;
int n,m,res[MAXN],cnt[MAXN],c2a[MAXN];
// n:陈述句个数 m:命题个数
// res[i]表示i这个命题是否被确定
// cnt[c]表示c这个条件还有几个前件没有确定
// c2a[c]表示c这个条件得到的结论
vector<int>a2c[MAXN]; // a2c[a]表示a这个前件会指向的集合
bool usable[MAXN]; // usable[c]表示c这个条件集合已经没用了(存在前件为假)

void init(){
	memset(res,-1,sizeof(res));memset(usable,true,sizeof(usable));
}
void noAns(){
	cout<<"conflict\n";exit(0);s
}
typedef char * pchar;
int isNum(pchar & pc){
	int re=0;
	while(*pc && *pc!=' ' && *pc!='\n'){
		if(*pc<'0' || *pc>'9'){
			++pc;
		}else{
			re=re*10+(*pc++)-'0';
		}
	}
	++pc;
	return re;
}
queue<int>aq;
bool assign(int a,int x){
	if(res[a]==!x){
		noAns();
		return false;
	}else if(res[a]==x){
		return false;
	}else{
		res[a]=x;
		return true;
	}
}
void gen(char * str,int c){
	char * p=str;
	if(strstr(str,"->")!=nullptr){
		int a;
		while( (a=isNum(p)) ){
			a2c[a].push_back(c);++cnt[c];
		}
		if(*p=='!'){ // a<0,为...->!a
			++p;a=-isNum(p);
		}else{
			a=isNum(p);
		}
		c2a[c]=a;
	}else{
		int a;
		if(*p=='!'){
			++p;a=isNum(p);assign(a,0);
		}else{
			a=isNum(p);assign(a,1);
		}
		aq.push(a);
	}
}
const int MAXLEN=MAXN<<2;
char str[MAXLEN];

void work(){
	while(aq.size()){
		int a=aq.front();aq.pop();
		if(res[a]==0){
			for(int c:a2c[a]){
				usable[c]=false;
			}
		}
		for(int c:a2c[a]){
			--cnt[c];
			if(cnt[c]==0 && usable[c]){
				usable[c]=false;
				int _a=c2a[c];
				if(_a<0){
					if(assign(-_a,0)){
						aq.push(-_a);
					}
				}else if(_a>0){
					if(assign(_a,1)){
						aq.push(_a);
					}
				}
			}
		}
	}
}

void prt(){
	for(int i=1;i<=m;++i){
		printf(res[i]==1?"T":"F");
	}
	printf("\n");
}
```

先`init()`，输入语句`str`后放入`gen(str)`里，然后跑`work()`就行



### 字典序最小2-SAT

```c++
const int MAXN=1e5+10;
struct TwoSatBF{ // 暴力求解字典序最小的解
	int n;vector<int>G[MAXN<<1];
	bool slt[MAXN<<1];
	// 偶数点：false 奇数点：true 这样x^1就是反面
	void init(int _n){
		n=_n;
		for(int i=0;i<(n<<1);++i){
			G[i].clear();slt[i]=false;
		}
	}
	void addLimit(int x,int y){
		// 选了x就要选y，具体看情况使用
		G[x].push_back(y);
		G[y^1].push_back(x^1);
	}
	stack<int>st;
	void clearst(){while(st.size()) st.pop();}
	bool dfs(int u){
		if(slt[u^1]){
			return false;
		}else if(slt[u]){
			return true;
		}
		slt[u]=true;
		st.push(u);
		for(auto v:G[u]){
			if(!dfs(v)){
				return false;
			}
		}
		return true;
	}
	bool solve(){
		for(int u=0;u<(n<<1);u+=2){
			if(!slt[u] && !slt[u^1]){
				clearst();
				if(!dfs(u)){
					clearst();
					if(!dfs(u^1)){
						return fales;
					}
				}
			}
		}
		return true;
	}
};
```



### $O(n+m)$的2-SAT

```c++
const int MAXN=2e6+10; // 注意开两倍空间
struct TwoSatSC{
	// x和x+1一组，其中x=2k，共n组，编号[0,2n-1]，注意编号是从0开始！
	void init(int _n){ // 多样例记得memset
		n=_n;
	}
	vector<int>G[MAXN];
	void add(int u,int v){
		// 选了u就要选v，不自带对称建边
		G[u].push_back(v);
	}
	int n,dfn[MAXN],low[MAXN],scid[MAXN];
	struct SC{
		int sz,pt;
	}sc[MAXN];
	stack<int>scst;
	bool inst[MAXN];
	void scdfs(int u){
		dfn[u]=low[u]=++dfn[0];
		scst.push(u);inst[u]=true;
		for(auto v:G[u]){
			if(!dfn[v]){
				scdfs(v);low[u]=min(low[u],low[v]);
			}else if(inst[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
		if(dfn[u]==low[u]){
			int id=++scid[0],v;
			while(scst.top()!=u){
				v=scst.top();scst.pop();inst[v]=false;
				++sc[id].sz;scid[v]=id;
			}
			scst.pop();inst[u]=false;
			++sc[id].sz;scid[u]=id;
		}
	}
	bool check(){
		for(int i=0;i<2*n;++i){
			if(!dfn[i]){
				scdfs(i);
			}
		}
		for(int i=0;i<2*n;i+=2){
			if(scid[i]==scid[i+1]){
				return false;
			}
		}
		return true;
	}
	void prt(){
		for(int i=0;i<2*n;i+=2){
			cout<<(scid[i]<scid[i+1]?"0 ":"1 ");
		}
	}
};
```



## 点双、圆方树、圆方树找桥和割点

```c++
#define pb push_back
const int MAXN=1e5+10;
vector<int>dc[MAXN],G[MAXN]，T[MAXN<<1];
int dfn[MAXN],low[MAXN],dccnt,sp;
stack<int>dcst;
void dcdfs(int u){
	dfn[u]=low[u]=++dfn[0];
	dcst.push(u);
	for(int v:G[u]){
		if(dfn[v]){
			low[u]=min(low[u],dfn[v]);
		}else{
			dcdfs(v);
			low[u]=min(low[u],low[v]);
			if(dfn[u]==low[v]){
				++dccnt;++sp;
				int x;
				do{
					x=dcst.top();dcst.pop();dc[dccnt].pb(x);
					T[x].pb(sp);T[sp].pb(x);
				}while(x!=v);
				dc[dccnt].pb(u);
				T[sp].pb(u);T[u].pb(sp);
			}
		}
	}
}
```

注意下：

1. 记考察去重、去自环、图连通性的影响
2. 图$G=\lang\{1,2\},\{(1,2)\}\rang$​也是一个点双，会被记录；只有一个点的平凡图并不会被记录，因为会被认为不属于任何点双
3. 圆方树`T`中，双连通分量会被拍成方点，每个原图中的点（被称为圆点）都会连接到所有其所在的双连通分量对应的方点上，特别的，如果一个方点连接了正好两个圆点，这两个圆点的边是一个桥；所有`T`中度大于1的都是割点
4. `sp`在一开始要置成`n`



# 网络流

## 建模技巧

* 只允许使用一次/不允许交叉：将一个点拆成两个点，连一条流量为1的边

  经典例题：[P4013 数字梯形问题](https://www.luogu.com.cn/problem/P4013)

* 可以建花费为负数的边，跑最小花费最大流求最大收益最大流

  在最大收益问题中，如果实际上并不要求最大流，可以建很多条从源点到限制点到汇点、花费为0、容量是某个合适值的路径，这样可以表示“不要这条路的可能的负收益”，即如果图中另一条路径满足了最大流但是花费为正（收益为负），此时会被这条新的路径覆盖

  经典例题：[Gym102800K](https://codeforces.com/gym/102800)

* 拆点是经常用的，想不到的时候可以直接拆点试试



## 二分图最大权匹配-匈牙利算法

时间复杂度：$O(n^3)$

```c++
template <typename T>struct hungarian {
	int n;
	vector<int> matchx,matchy;  // 左右集合对应的匹配点
	vector<int> pre;     // 连接右集合的左点
	vector<bool> visx,visy;   // 拜访数组 左右
	vector<T> lx,ly;
	vector<vector<T> > g;
	vector<T> slack;
	T inf,res;
	queue<int> q;
	int org_n,org_m;

	hungarian(int _n, int _m) {
		org_n = _n;
		org_m = _m;
		n = max(_n, _m);
		inf = numeric_limits<T>::max();
		res = 0;
		g = vector<vector<T> >(n, vector<T>(n));
		matchx = vector<int>(n, -1);
		matchy = vector<int>(n, -1);
		pre = vector<int>(n);
		visx = vector<bool>(n);
		visy = vector<bool>(n);
		lx = vector<T>(n, -inf);
		ly = vector<T>(n);
		slack = vector<T>(n);
	}

	void addEdge(int u, int v, T w) {
        if(w<0){ // 负权不如不匹配
            g[u][v]=0;
        }else{
            g[u][v] = w;
        }
	}
	bool check(int v) {
		visy[v] = true;
		if (matchy[v] != -1) {
			q.push(matchy[v]);
			visx[matchy[v]] = true;  // in S
			return false;
		}
		// 找到新的未匹配点 更新匹配点 pre 数组记录着"非匹配边"上与之相连的点
		while (v != -1) {
			matchy[v] = pre[v];
			swap(v, matchx[pre[v]]);
		}
		return true;
	}

	void bfs(int i) {
	    while (!q.empty()) {
		    q.pop();
	    }
	    q.push(i);
		visx[i] = true;
		while (true) {
			while (!q.empty()) {
				int u = q.front();
				q.pop();
				for (int v = 0; v < n; v++) {
					if (!visy[v]) {
						T delta = lx[u] + ly[v] - g[u][v];
						if (slack[v] >= delta) {
							pre[v] = u;
							if (delta) {
		            			slack[v] = delta;
		          			} else if (check(v)) {  // delta=0 代表有机会加入相等子图 找增广路
		                                  // 找到就return 重建交错树
		            			return;
		          			}
		        		}
		      		}
		    	}
		  	}
		  // 没有增广路 修改顶标
		  	T a = inf;
			for (int j = 0; j < n; j++) {
			    if (!visy[j]) {
				    a = min(a, slack[j]);
		    	}
		  	}
		  	for (int j = 0; j < n; j++) {
		    	if (visx[j]) {  // S
		    		lx[j] -= a;
		    	}
		    	if (visy[j]) {  // T
		    		ly[j] += a;
		    	} else {  // T'
		    		slack[j] -= a;
		    	}
		  	}
		  	for (int j = 0; j < n; j++) {
		    	if (!visy[j] && slack[j] == 0 && check(j)) {
		      		return;
		    	}
		  	}
		}
	}

	void solve() {
		// 初始顶标
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				lx[i] = max(lx[i], g[i][j]);
			}
    	}

    	for (int i = 0; i < n; i++) {
    		fill(slack.begin(), slack.end(), inf);
    		fill(visx.begin(), visx.end(), false);
    		fill(visy.begin(), visy.end(), false);
    		bfs(i);
    	}

    	// custom
    	for (int i = 0; i < n; i++) {
    		if (g[i][matchx[i]] > 0) {
        		res += g[i][matchx[i]];
      		} else {
        		matchx[i] = -1;
      		}
    	}
	    // cout << res << "\n";
	    // for (int i = 0; i < org_n; i++) {
	    // 	cout << matchx[i] + 1 << " ";
	    // }
	    // cout << "\n";
  	}
};
// in main.cpp
int n;
cin>>n>>m; // 图左右的点数量
hungarian<int> solver(n,m);
while(ecnt--){
    int u,v,w;
    solver.addEdge(u-1,v-1,w); // solver里面的下标都是从0开始，u,v表示左右第几个点
    solver.solve();
}
```



## 最大流-Dinic算法

```c++
const int MAXN=2010;
const int INF=0x3f3f3f3f;
struct Dinic {
	struct Edge {
		int from, to, cap, flow;
  		Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
	};
	int n, m, s, t;
	vector<Edge>edges;
	vector<int>G[MAXN];
	int d[MAXN],cur[MAXN];bool vis[MAXN];

	void init(int n) {
        this->n=n;
    	for (int i = 0; i <=n; i++) G[i].clear();
    	edges.clear();
  	}

	void addEdge(int from, int to, int cap) {
		edges.push_back(Edge(from, to, cap, 0));
		edges.push_back(Edge(to, from, 0, 0));
		m = edges.size();
		G[from].push_back(m - 2);
		G[to].push_back(m - 1);
	}

	bool BFS() {
		memset(vis, 0, sizeof(vis));
		queue<int> Q;Q.push(s);d[s] = 0;vis[s] = 1;
		while (!Q.empty()) {
			int x = Q.front();Q.pop();
			for (int i = 0; i < G[x].size(); i++) {
				Edge& e = edges[G[x][i]];
				if (!vis[e.to] && e.cap > e.flow) {
					vis[e.to] = 1;
					d[e.to] = d[x] + 1;
					Q.push(e.to);
				}
			}
		}
		return vis[t];
	}

	int DFS(int x,int a) {
		if (x == t || a == 0) return a;
		int flow = 0, f;
		for (int& i = cur[x]; i < G[x].size(); i++) {
			Edge& e = edges[G[x][i]];
			if (d[x]+1==d[e.to] && (f=DFS(e.to,min(a,e.cap-e.flow))) > 0) {
				e.flow += f;
				edges[G[x][i] ^ 1].flow -= f;
				flow += f;a -= f;
				if (a == 0) break;
			}
		}
		return flow;
	}

	int maxFlow(int s, int t) {
		this->s = s;
		this->t = t;
		int flow = 0;
		while (BFS()) {
			memset(cur, 0, sizeof(cur));
			flow += DFS(s, INF);
		}
		return flow;
	}
}dinic;
```

时间复杂度$O(n^2m)$，在二分图最大匹配时是$O(m\sqrt n)$

注意：

* 在输出方案时，遍历边，并且判断边是否是满的（`e.flow==e.cap`）
* 使用`.maxFlow(s,t)`求最大流



## 最小割

最小割相当于把图中所有点分成两个集合`S`、`T`（其中源点在`S`集合、汇点在`T`集合）且要求所有`S`到`T`的边的花费和最小

最大流等于最小割

跑完最小割之后，在输出方案的时候，从`s`开始，根据边是否有残差流量来`dfs`，这样可以找到所有`S`集合的点



## 最小花费最大流-SSP算法

```c++
const int N = 5e3 + 5, M = 1e5 + 5;
const int INF = 0x3f3f3f3f;

struct MCMF{
	int n,m,tot=1,lnk[N],ter[M],nxt[M],cap[M],cost[M];
	int cur[N],dis[N],ret; // ret:最小花费
	bool vis[N];
	void init(){
		tot=1;ret=0;memset(lnk,0,sizeof(lnk));
	}
	void _add(int u,int v,int w,int c) {
		ter[++tot]=v;nxt[tot]=lnk[u];lnk[u]=tot;cap[tot]=w;cost[tot]=c;
	}
	void addEdge(int u,int v,int w,int c) {
		_add(u, v, w, c);_add(v, u, 0, -c);
	}
	bool spfa(int s,int t){
		memset(dis,0x3f,sizeof(dis));
		memcpy(cur,lnk,sizeof(lnk));
		queue<int>q;q.push(s);dis[s]=0;vis[s]=true;
		while(!q.empty()){
			int u=q.front();q.pop();vis[u]=false;
			for(int ie=lnk[u];ie;ie=nxt[ie]){
				int v=ter[ie];
				if(cap[ie] && dis[v]>dis[u]+cost[ie]){
					dis[v]=dis[u]+cost[ie];
					if(!vis[v]) q.push(v),vis[v]=true;
				}
			}
		}
		return dis[t]!=INF;
	}
	int dfs(int u,int t,int flow){
		if(u==t) return flow;
		vis[u]=true;
		int ans=0;
		for(int & ie=cur[u];ie && ans<flow;ie=nxt[ie]){
			int v=ter[ie];
			if(!vis[v] && cap[ie] && dis[v]==dis[u]+cost[ie]){
				int x=dfs(v,t,min(cap[ie],flow-ans));
				if(x) ret+=x*cost[ie],cap[ie]-=x,cap[ie^1]+=x,ans+=x;
			}
		}
		vis[u]=false;
		return ans;
	}
	int mcmf(int s,int t){
		int ans=0;
		while(spfa(s,t)){
			int x;
			while( ( x=dfs(s,t,INF) ) ) ans+=x;
		}
		return ans; // 最大流，ret是花费
	}
};
```

时间复杂度：$O(mnf)$，其中$f$为最大流



## 全局最小割-StoerWagner算法

```c++
const int MAXN=610,INF=0x3f3f3f3f;
int ew[MAXN][MAXN],n,m,sd[MAXN];bool vis[MAXN],bin[MAXN];
int contract(int & s, int & t){
	memset(sd,0,sizeof(sd));memset(vis,false,sizeof(vis));
	int k,maxc,mncut=0;
	for(int i=1;i<=n;++i){
		k=-1;maxc=-1;
		for(int j=1;j<=n;++j){
			if(!vis[j] && !bin[j] && sd[j]>maxc){
				maxc=sd[j];k=j;
			}
		}
		if(k==-1){ // 此时已经选完
			return mncut;
		}
		s=t;t=k;mncut=maxc;vis[k]=true;
		for(int j=1;j<=n;++j){
			if(!vis[j] && !bin[j]) sd[j]+=ew[k][j];
		}
	}
	return mncut;
}
int StoerWagner(){
	int ans=INF,s,t;
	for(int i=1;i<=n-1;++i){
		ans=min(ans,contract(s,t));
		// 用s与t不属于同一集合时的最小割更新答案；s和t本质是随机选的
		bin[t]=true; // s与t属于同一集合
		for(int j=1;j<=n;++j){
			if(!bin[j]) {
				ew[s][j]+=ew[j][t];ew[j][s]+=ew[j][t];
			}
		}
	}
	return ans;
}
```

小心重边（自环无所谓）



# 其他

## 手写梅森旋转生成随机数

需要`C++11`

```c++
struct MT19937{
    bool isInit;int index,MT[624];
    void srand(int seed){
        index = 0;
        isInit = 1;
        MT[0] = seed;
        for(int i=1; i<624; i++){
            int t = 1812433253 * (MT[i-1] ^ (MT[i-1] >> 30)) + i;
            MT[i] = t & 0xffffffff;   //取最后的32位
        }
    }
    void generate(){
        for(int i=0; i<624; i++){
            int y = (MT[i] & 0x80000000) + (MT[(i+1) % 624] & 0x7fffffff);
            MT[i] = MT[(i + 397) % 624] ^ (y >> 1);
            if (y & 1) MT[i] ^= 2567483615;
        }
    }
    int rand(){
        if(index == 0)
            generate();
        int y = MT[index];
        y = y ^ (y >> 11);
        y = y ^ ((y << 7) & 2636928640);
        y = y ^ ((y << 15) & 4022730752);
        y = y ^ (y >> 18);
        index = (index + 1) % 624;
        return y;
    }
}mt;
// in main
mt.srand(0);  //设置随机种子
```

